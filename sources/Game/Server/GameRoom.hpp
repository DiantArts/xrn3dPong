#pragma once

#include <xrn/Engine/Components.hpp>
#include <Game/MessageType.hpp>
#include <Game/Server/Ball.hpp>
#include <Game/Server/Player.hpp>

namespace game::server {

///////////////////////////////////////////////////////////////////////////
/// \brief Room for 2 players to play in
/// \ingroup game
///
/// \include GameRoom.hpp <Game/Server/GameRoom.hpp>
///
///////////////////////////////////////////////////////////////////////////
class GameRoom
{

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Static
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    using Message = ::xrn::network::Message<::game::MessageType>;




public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Connection creating a new game room
    ///
    ///////////////////////////////////////////////////////////////////////////
    GameRoom(
        ::std::shared_ptr<::xrn::network::Connection<::game::MessageType>> connection
    );



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Rule of 5
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Destructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    virtual ~GameRoom();

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    GameRoom(
        const GameRoom&
    ) noexcept = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        const GameRoom&
    ) noexcept
        -> GameRoom& = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    GameRoom(
        GameRoom&&
    ) noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        GameRoom&&
    ) noexcept
        -> GameRoom&;




    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Player manipulation
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Is the room currently occupied by 2 players
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto isFull() const
        -> bool;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Is the room currently occupied by 2 players
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto isRunning() const
        -> bool;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Does the room contains the player in argument
    ///
    /// 0: Does not contain the player
    /// 1: Connection is Player1
    /// 2: Connection is Player2
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto contains(
        ::std::shared_ptr<::xrn::network::Connection<::game::MessageType>> connection
    ) const
        -> ::std::uint8_t;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the opponent of the player in argument
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getOpponent(
        ::std::shared_ptr<::xrn::network::Connection<::game::MessageType>> player
    ) -> ::std::shared_ptr<::xrn::network::Connection<::game::MessageType>>;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the player
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getPlayer1()
        -> ::std::shared_ptr<::xrn::network::Connection<::game::MessageType>>;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    void setPlayer1Position(
        ::glm::vec3&& position
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the player
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getPlayer2()
        -> ::std::shared_ptr<::xrn::network::Connection<::game::MessageType>>;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    void setPlayer2Position(
        ::glm::vec3&& position
    );

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    void udpSendToBothClients(
        ::std::unique_ptr<GameRoom::Message> message1
    );

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    void tcpSendToBothClients(
        ::std::unique_ptr<GameRoom::Message> message1
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Join an already existing game
    ///
    ///////////////////////////////////////////////////////////////////////////
    void joinGame(
        ::std::shared_ptr<::xrn::network::Connection<::game::MessageType>> connection
    );



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Events
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    void createBall();

    ///////////////////////////////////////////////////////////////////////////
    void resetBalls();

    ///////////////////////////////////////////////////////////////////////////
    /// called with the m_tickFrequencyTime per seconds
    ///
    /// Start ticking when the second player is in the lobby
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto onTick(
        ::xrn::Time deltaTime
        , ::std::size_t index
    ) -> bool;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    void triggerWin(
        ::std::uint8_t winnerId
    );



private:

    ::game::server::Player m_player1;
    ::game::server::Player m_player2;

    bool m_isRunning{ false };

    ::std::vector<::game::server::Ball> m_balls;

    // Tick
    ::std::thread m_tickThread;
    ::xrn::Time m_tickFrequencTime;
    ::xrn::Time m_ballSpawnFrequencyTime;

};

} // namespace game::server
