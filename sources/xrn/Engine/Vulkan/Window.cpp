///////////////////////////////////////////////////////////////////////////
// Precompilled headers
///////////////////////////////////////////////////////////////////////////
#include <pch.hpp>

///////////////////////////////////////////////////////////////////////////
// Headers
///////////////////////////////////////////////////////////////////////////
#include <xrn/Engine/Vulkan/Window.hpp>
#include <xrn/Engine/Event/WindowResize.hpp>
#include <xrn/Engine/Event/KeyPressed.hpp>
#include <xrn/Engine/Event/KeyReleased.hpp>
#include <xrn/Engine/Event/MouseMoved.hpp>

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// static elements
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::vulkan::Window::Size::isValid()
    -> bool
{
    return !(!this->width || !this->height);
}

///////////////////////////////////////////////////////////////////////////
::xrn::engine::vulkan::Window::Size::operator VkExtent2D() const
{
    return { .width = static_cast<::std::uint32_t>(width), .height = static_cast<::std::uint32_t>(height) };
}


///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Constructors
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
::xrn::engine::vulkan::Window::Window(
    bool isFullscreen, /* = true */
    const ::std::string& windowName /* = Window::defaultName */
)
    : m_size{ Window::defaultSize }
    , m_pWindow{ ::glfwCreateWindow(
        m_size.width,
        m_size.height,
        windowName.c_str(),
        isFullscreen ? ::glfwGetPrimaryMonitor() : nullptr,
        nullptr
    ) }
{
    XRN_ASSERT(!!m_pWindow, "Create glfw window");

    ::glfwSetWindowUserPointer(m_pWindow.get(), &m_events);
    ::glfwSetCursorPos(m_pWindow.get(), m_size.width / 2, m_size.height / 2);
    ::glfwSetInputMode(m_pWindow.get(), GLFW_CURSOR, GLFW_CURSOR_HIDDEN);

    // setup callbacks
    ::glfwSetFramebufferSizeCallback(m_pWindow.get(), Window::framebufferResizeCallback);
    ::glfwSetKeyCallback(m_pWindow.get(), Window::keyCallback);
    ::glfwSetCursorPosCallback(m_pWindow.get(), Window::mouseMovedCallback);

    // ::glfwSetScrollCallback(m_pWindow.get(), Window::mouseScrollcallback);
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Rule of 5
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
::xrn::engine::vulkan::Window::~Window() = default;

///////////////////////////////////////////////////////////////////////////
::xrn::engine::vulkan::Window::Window(
    Window&&
) noexcept = default;

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::vulkan::Window::operator=(
    Window&&
) noexcept
    -> Window& = default;



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Basic operations
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::vulkan::Window::shouldClose() const
    -> bool
{
    return ::glfwWindowShouldClose(m_pWindow.get()) || m_shouldClose;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::clear() const
{
    // ::glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::close()
{
    ::glfwSetWindowShouldClose(m_pWindow.get(), GLFW_TRUE);
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::display() const
{
    // ::glfwSwapBuffers(m_pWindow.get());
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::handleEvents(
    ::xrn::engine::AScene& scene
)
{
    ::glfwPollEvents();
    m_events.resolve(scene);
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::vulkan::Window::wasResized()
    -> bool
{
    return m_framebufferResized;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::resetResizedFlag()
{
    m_framebufferResized = false;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::setResizedFlag()
{
    m_framebufferResized = true;
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::resize(
    const Window::Size& size
)
{
    m_size.width = size.width;
    m_size.height = size.height;
    this->setResizedFlag();
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Other
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
auto ::xrn::engine::vulkan::Window::getSize() const
    -> const Window::Size&
{
    return m_size;
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Vulkan implementation
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::createWindowSurface(
    ::VkInstance instance,
    ::VkSurfaceKHR* surface
)
{
    XRN_ASSERT(
        ::glfwCreateWindowSurface(instance, m_pWindow.get(), nullptr, surface) == VK_SUCCESS,
        "Create glfw window surface"
    );
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// GLFW callbacks
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::framebufferResizeCallback(
    ::GLFWwindow* pWindow,
    const int width,
    const int height
) {
    auto& events{ *reinterpret_cast<::xrn::engine::event::Container*>(::glfwGetWindowUserPointer(pWindow)) };
    events.emplace<::xrn::engine::event::WindowResize>(Window::Size{
        .width = static_cast<::std::size_t>(width),
        .height = static_cast<::std::size_t>(height)
    });
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::keyCallback(
    GLFWwindow* pWindow,
    const int keyCode,
    const int scancode,
    const int action,
    const int mods
)
{
    auto& events{ *reinterpret_cast<::xrn::engine::event::Container*>(::glfwGetWindowUserPointer(pWindow)) };
    if (action == GLFW_PRESS) {
        events.emplace<::xrn::engine::event::KeyPressed>(keyCode);
    } else if (action == GLFW_RELEASE) {
        events.emplace<::xrn::engine::event::KeyReleased>(keyCode);
    }
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::mouseMovedCallback(
    GLFWwindow* pWindow,
    const double xPos,
    const double yPos
)
{
    auto& events{ *reinterpret_cast<::xrn::engine::event::Container*>(::glfwGetWindowUserPointer(pWindow)) };
    int width, height;
    ::glfwGetWindowSize(pWindow, &width, &height);
    events.emplace<::xrn::engine::event::MouseMoved>(xPos - width / 2, yPos - height / 2);
    ::glfwSetCursorPos(pWindow, width / 2, height / 2);

}

void ::xrn::engine::vulkan::Window::mouseScrollcallback(
    GLFWwindow*,
    const double,
    const double yOffset
)
{}





///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// GLFW memory
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
void ::xrn::engine::vulkan::Window::Deleter::operator()(
    ::GLFWwindow* pWindow
)
{
    ::glfwDestroyWindow(pWindow);
}

///////////////////////////////////////////////////////////////////////////
class GlfwMemoryManager {
    GlfwMemoryManager()
    {
        XRN_ASSERT(::glfwInit(), "Init glfw");
        ::glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
        ::glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);
        // stbi_set_flip_vertically_on_load(true);
    }

    ~GlfwMemoryManager()
    {
        ::glfwTerminate();
    }

    static const GlfwMemoryManager _;
};
const ::GlfwMemoryManager GlfwMemoryManager::_;
